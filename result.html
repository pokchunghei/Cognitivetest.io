<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MBTI 測試結果</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #2196F3;
    }
    .bar {
      display: flex;
      align-items: center;
      margin: 10px 0;
    }
    .bar-label {
      width: 50px;
      text-align: left;
    }
    .bar-fill {
      height: 30px;
      border-radius: 5px;
      margin-left: 10px;
      background-color: #2196F3;
      color: white;
      font-weight: bold;
      padding-left: 6px;
      line-height: 30px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    table, th, td {
      border: 1px solid #ddd;
    }
    th, td {
      padding: 8px;
      text-align: center;
    }
    .analysis {
      margin-top: 20px;
      padding: 10px;
      background-color: #e7f3fe;
      border-left: 6px solid #2196F3;
      border-radius: 4px;
    }
    .mbti-display {
      margin-top: 20px;
      padding: 10px;
      background-color: #fff9e6;
      border-left: 6px solid #ffc107;
      border-radius: 4px;
    }
	.button {
      background-color: #4a90e2;
      color: white;
      padding: 10px 20px;
      margin-top: 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
    }
	.home-link {
      display: block;
      margin-bottom: 20px;
      font-size: 15px;
      color: #2196F3;
      text-decoration: none;
    }
	.chart-description {
	  margin: 10px 0;
	  padding: 10px;
	  background-color: #f8f9fa;
	  font-size: 14px;
	  color: #555;
	  text-align: center;
	}
	
	.chart-description p {
	  margin: 0;
	}
	.bottom-text {
	  margin-top: 15px;
	  padding: 15px;
	  text-align: center;
	  font-size: 15px;
	  color: #1a365d;
	  line-height: 1.7;
	}
	
	.bottom-text p:first-child {
	  font-weight: 500;
	  color: #2c3e50;
	}
  </style>
</head>
<body>
  <a href="page2.html" class="homelink">重新測試</a>
  <div class="container">
    <h1>MBTI 測試結果</h1>

    <!-- 棒形圖容器 -->
    <div id="results"></div>

	<div class="chart-description">
	  <p>記得截圖保存八維分數呀!</p>
	</div>
	  
<h2>分數表</h2>
<table>
  <tbody id="scoreTableBody"></tbody>
</table>
    
    <div class="mbti-display">
      <h2><strong>MBTI</strong></h2>
      <p>第一選擇：<span id="finalFirstChoice"></span></p>
      <p>第二選擇：<span id="finalSecondChoice"></span></p>
    </div>

    <div class="analysis" id="pairDescription">
      <h3>性格分析</h3>
      <p id="synergyText"></p>
    </div>

    <div class="bottom-text">
      <p><i>測試結果與16型人格不同？</i><br>當然了，<strong>16 personalities不是MBTI呀！</strong><br>MBTI由Ne、Si等功能組成，提供了内外傾維度<br>，比16型人格的單向N/S更準確。<br>（上方了解更多“MBTI是甚麽？）</p>
    </div>
  </div>

<script>
    // --------------- 1) 讀取分數，顯示棒形圖、分數表、排序 ---------------
    const scores = JSON.parse(localStorage.getItem('mbtiScores')) || {
      Ne: 0, Ni: 0, Se: 0, Si: 0, Te: 0, Ti: 0, Fe: 0, Fi: 0
    };
    const maxScore = 30; // 每個功能的最高分數

    // 將分數轉換為數組並排序
    const sortedScores = Object.entries(scores).sort((a, b) => b[1] - a[1]);

    const resultsDiv = document.getElementById('results');
    const scoreCells = {
      Ne: document.getElementById('score-Ne'),
      Ni: document.getElementById('score-Ni'),
      Se: document.getElementById('score-Se'),
      Si: document.getElementById('score-Si'),
      Te: document.getElementById('score-Te'),
      Ti: document.getElementById('score-Ti'),
      Fe: document.getElementById('score-Fe'),
      Fi: document.getElementById('score-Fi'),
    };

    // 取得表格主體
    const tableBody = document.getElementById('scoreTableBody');

    // 先建立兩個 row
    const funcRow = document.createElement('tr');
    const scoreRow = document.createElement('tr');
    
    // 加第一個欄位「功能」「分數」
    const funcHeader = document.createElement('td');
    funcHeader.innerText = "功能";
    funcRow.appendChild(funcHeader);
    
    const scoreHeader = document.createElement('td');
    scoreHeader.innerText = "分數";
    scoreRow.appendChild(scoreHeader);
    
    // 依照排序好的 scores 動態生成
    sortedScores.forEach(([func, value]) => {
      const funcCell = document.createElement('td');
      funcCell.innerText = func;
      funcRow.appendChild(funcCell);
    
      const scoreCell = document.createElement('td');
      scoreCell.innerText = value;
      scoreRow.appendChild(scoreCell);
    });
    
    // 把兩行加進 table
    tableBody.appendChild(funcRow);
    tableBody.appendChild(scoreRow);
    
    // 生成棒形圖
    sortedScores.forEach(([func, value]) => {
      const bar = document.createElement('div');
      bar.className = 'bar';
      bar.innerHTML = `
        <div class="bar-label">${func}</div>
        <div class="bar-fill" style="width: ${value * 100 / maxScore}%;">
          ${value}
        </div>
      `;
      resultsDiv.appendChild(bar);
    });

    // --------------- 2) MBTI 產生邏輯：找最高、次高分功能 → 兩個候選 ---------------
    const topFuncName = sortedScores[0][0];     // 第一高分功能
    const secondFuncName = sortedScores[1][0];  // 第二高分功能

    // 依功能找出搭配的功能，組合出 MBTI
    function getMBTICandidate(funcName) {
      let orientation, letter2, letter3, letter4, pairedFunc;
      // 分成4類：
      if (['Ne', 'Se'].includes(funcName)) {
        orientation = 'E';
        letter2 = funcName[0].toUpperCase();  // N or S
        pairedFunc = (scores.Ti >= scores.Fi) ? 'Ti' : 'Fi';
        letter3 = pairedFunc[0].toUpperCase(); // T or F
        letter4 = 'P';  // 外傾感知 → P
      }
      else if (['Te', 'Fe'].includes(funcName)) {
        orientation = 'E';
        letter3 = funcName[0].toUpperCase(); // T or F
        pairedFunc = (scores.Ni >= scores.Si) ? 'Ni' : 'Si';
        letter2 = pairedFunc[0].toUpperCase(); // N or S
        letter4 = 'J';  // 外傾判斷 → J
      }
      else if (['Ni', 'Si'].includes(funcName)) {
        orientation = 'I';
        letter2 = funcName[0].toUpperCase(); // N or S
        pairedFunc = (scores.Te >= scores.Fe) ? 'Te' : 'Fe';
        letter3 = pairedFunc[0].toUpperCase(); // T or F
        letter4 = 'J';  // 內傾感知 → 外傾判斷(Te/Fe) → J
      }
      else if (['Ti', 'Fi'].includes(funcName)) {
        orientation = 'I';
        letter3 = funcName[0].toUpperCase(); // T or F
        pairedFunc = (scores.Ne >= scores.Se) ? 'Ne' : 'Se';
        letter2 = pairedFunc[0].toUpperCase(); // N or S
        letter4 = 'P';  // 內傾判斷 → 外傾感知(Ne/Se) → P
      }
      // 分數總和用於比較
      const sumScores = scores[funcName] + scores[pairedFunc];
      const mbti = orientation + letter2 + letter3 + letter4;
      return { mbti, sumScores };
    }

    const candidate1 = getMBTICandidate(topFuncName);
    const candidate2 = getMBTICandidate(secondFuncName);

    // 比較兩個候選 MBTI 的 2功能分數
    let finalFirstChoice, finalSecondChoice;
    if (candidate1.sumScores >= candidate2.sumScores) {
      finalFirstChoice = candidate1.mbti;
      finalSecondChoice = candidate2.mbti;
    } else {
      finalFirstChoice = candidate2.mbti;
      finalSecondChoice = candidate1.mbti;
    }

    document.getElementById('finalFirstChoice').innerText = finalFirstChoice;
    document.getElementById('finalSecondChoice').innerText = finalSecondChoice;

    // --------------- 新增：功能描述字典 ---------------
    const functionDescriptions = {
      Ne: ["想象和聯想力較豐富", "想象和聯想力十分豐富"],
      Ni: ["做事較專注深入", "做事十分專注和深入"],
      Se: ["偏向活在當下及時行樂", "鍾情活在當下及時行樂"],
      Si: ["依賴記憶行事謹慎", "十分依賴記憶、行事非常謹慎"],
      Te: ["管理和領導力較強", "管理和領導力很強"],
      Ti: ["自我邏輯較強", "自我邏輯很強"],
      Fe: ["共情能力較強", "共情能力很強"],
      Fi: ["擁有明確自我價值觀和底綫", "堅守自我價值觀和底綫"]
    };

    const functionParagraphs = {
      Ne: [
        "你的想像力豐富，思維跳脫、天馬行空，認為世界有許多可能性，也許身邊有人會認為你是一名瘋子！",
        "你的想像力不錯，有時會有天馬行空的想法，可以跳出框框，不被已有思維局限。"
      ],
      Ni: [
        "你的洞察力強，善於理解和組織無法言語的概念，對抽象事物有獨特深刻的見解，專注熱愛的事情時也可以廢寢忘餐。",
        "你的洞察力不錯，有時可以理解和組織一些無法言語的概念，給出獨特且有深度的見解。"
      ],
      Se: [
        "你喜歡活在當下，歡迎各種新鮮的體驗，就算take risk也渴望嘗試新事物，而且你也喜歡邀約朋友，或許是一名社交恐怖分子！",
        "你有時喜歡嘗試新鮮的體驗，約見朋友，嘗試新餐廳和遊覽新地方，躲在家中還不是你的作風呢！"
      ],
      Si: [
        "你習慣依賴記憶作決策，行事謹慎穩妥，三思而後行，有時略顯固執，而且觀察力強，善於記住過去的細節。",
        "你傾向依賴記憶作決策，行事較為謹慎穩妥，有新的想法和決定也會先思考是否適合自己。"
      ],
      Te: [
        "你善於組織和管理，善於擔任領導角色，行事有計劃、追求效率，喜歡用最快的方法達到目的、解決問題，也會將身處的環境打理得整整齊齊。",
        "你的組織和領導能力不錯，可以顧全大局作出決策，行事傾向先計畫和追求效率，儘快達到目的解決問題。"
      ],
      Ti: [
        "你的分析力強，腦海裏有很清晰的邏輯，善於發現身邊事物的邏輯問題，著重分析和解決問題的過程，但經常容易與人辯論，渴望證明自己的邏輯。",
        "你的分析能力不錯，有自己的一套邏輯，容易發現身邊事物的邏輯問題，解決問題時也較著重原因和過程多於結果。"
      ],
      Fe: [
        "你的共情能力強，會顧及他人的感受，喜歡分享快樂，容易感受到他人的情緒，經常默默忍讓自我奉獻，只為令他人高興。",
        "你的共情能力不錯，會顧及他人的感受，喜歡分享快樂，容易感受到他人的情緒，有時會犧牲自己的感受令大家高興。"
      ],
      Fi: [
        "你很重視自己的感受，會堅守自己的價值觀和底綫，決策時大多先考慮自己的感受。",
        "你頗重視自己的感受，有一套自己的價值觀，決策時也傾向先考慮自己的感受。"
      ]
    };

	// --------------- 新增：生成主导功能和辅助功能 ---------------
	function generateFunctionAnalysis() {
	  const topFunc = sortedScores[0];
	  const topFuncName = topFunc[0];
	  const topFuncScore = topFunc[1];
	  
	  // 1. 确定主导功能
	  const dominantFunctions = [topFunc];
	  
	  // 2. 找出同倾向功能
	  const topOrientation = functionOrientations[topFuncName];
	  const sameOrientationFuncs = sortedScores.filter(
	    ([func, score]) => functionOrientations[func] === topOrientation && 
	                      func !== topFuncName && 
	                      score >= 15 && 
	                      Math.abs(score - topFuncScore) <= 5
	  );
	  
	  // 3. 添加第二主导功能
	  if (sameOrientationFuncs.length > 0) {
	    sameOrientationFuncs.sort((a, b) => b[1] - a[1]);
	    dominantFunctions.push(sameOrientationFuncs[0]);
	    
	    // 4. 检查是否需要添加第三、第四主导功能
	    for (let i = 1; i < sameOrientationFuncs.length; i++) {
	      if (Math.abs(sameOrientationFuncs[i][1] - sameOrientationFuncs[0][1]) <= 1) {
	        dominantFunctions.push(sameOrientationFuncs[i]);
	      }
	    }
	  }
	  
	  // 5. 找出相反倾向功能 (辅助功能)
	  const oppositeOrientationFuncs = sortedScores.filter(
	    ([func, score]) => functionOrientations[func] !== topOrientation
	  );
	  
	  // 6. 分组相反倾向功能 - 基于主导功能倾向性
	  let groupA = []; // 感知功能组
	  let groupB = []; // 判断功能组
	  
	  if (topOrientation === "E") {
	    // 主导功能是外倾，辅助功能应该是内倾
	    groupA = oppositeOrientationFuncs.filter(
	      ([func, score]) => ["Ni", "Si"].includes(func)
	    );
	    groupB = oppositeOrientationFuncs.filter(
	      ([func, score]) => ["Ti", "Fi"].includes(func)
	    );
	  } else {
	    // 主导功能是内倾，辅助功能应该是外倾
	    groupA = oppositeOrientationFuncs.filter(
	      ([func, score]) => ["Ne", "Se"].includes(func)
	    );
	    groupB = oppositeOrientationFuncs.filter(
	      ([func, score]) => ["Te", "Fe"].includes(func)
	    );
	  }
	  
	  // 7. 选择辅助功能
	  const auxiliaryFunctions = [];
	  
	  // 从每组中选择最高分者
	  let candidateA = groupA.length > 0 ? groupA[0] : null;
	  let candidateB = groupB.length > 0 ? groupB[0] : null;
	  
	  // 8. 检查功能链匹配
	  const functionChains = [];
	  const matchedAuxFunctions = [];
	  
	  // 首先尝试用candidateA完成两种匹配
	  if (candidateA) {
	    const auxFuncName = candidateA[0];
	    let hasPerceptionOrJudgmentChain = false;
	    let hasMBTIChain = false;
	    let matchedDomFunc = null;
	    
	    for (const domFunc of dominantFunctions) {
	      const domFuncName = domFunc[0];
	      const chainType = getFunctionChainType(domFuncName, auxFuncName);
	      
	      if (chainType === "感知功能鏈" || chainType === "判斷功能鏈") {
	        hasPerceptionOrJudgmentChain = true;
	        matchedDomFunc = domFuncName;
	      }
	      if (chainType === "MBTI功能鏈") {
	        hasMBTIChain = true;
	        matchedDomFunc = domFuncName;
	      }
	      
	      if (hasPerceptionOrJudgmentChain && hasMBTIChain) {
	        functionChains.push(`${domFuncName}-${auxFuncName}(${chainType})`);
	        matchedAuxFunctions.push(candidateA);
	        break;
	      }
	    }
	    
	    // 如果找到一种匹配，记录它
	    if ((hasPerceptionOrJudgmentChain || hasMBTIChain) && !matchedAuxFunctions.includes(candidateA)) {
	      functionChains.push(`${matchedDomFunc}-${auxFuncName}(${hasPerceptionOrJudgmentChain ? "感知/判斷功能鏈" : "MBTI功能鏈"})`);
	      matchedAuxFunctions.push(candidateA);
	    }
	  }
	  
	  // 如果candidateA无法完成两种匹配，尝试用candidateB完成剩下的匹配
	  if (candidateB && matchedAuxFunctions.length < 2) {
	    const auxFuncName = candidateB[0];
	    let hasPerceptionOrJudgmentChain = false;
	    let hasMBTIChain = false;
	    let matchedDomFunc = null;
	    
	    for (const domFunc of dominantFunctions) {
	      const domFuncName = domFunc[0];
	      const chainType = getFunctionChainType(domFuncName, auxFuncName);
	      
	      if (chainType === "感知功能鏈" || chainType === "判斷功能鏈") {
	        hasPerceptionOrJudgmentChain = true;
	        matchedDomFunc = domFuncName;
	      }
	      if (chainType === "MBTI功能鏈") {
	        hasMBTIChain = true;
	        matchedDomFunc = domFuncName;
	      }
	      
	      if (hasPerceptionOrJudgmentChain && hasMBTIChain) {
	        functionChains.push(`${domFuncName}-${auxFuncName}(${chainType})`);
	        if (!matchedAuxFunctions.some(af => af[0] === auxFuncName)) {
	          matchedAuxFunctions.push(candidateB);
	        }
	        break;
	      }
	    }
	    
	    // 如果找到一种匹配，记录它
	    if ((hasPerceptionOrJudgmentChain || hasMBTIChain) && !matchedAuxFunctions.some(af => af[0] === auxFuncName)) {
	      functionChains.push(`${matchedDomFunc}-${auxFuncName}(${hasPerceptionOrJudgmentChain ? "感知/判斷功能鏈" : "MBTI功能鏈"})`);
	      matchedAuxFunctions.push(candidateB);
	    }
	  }
	  
	  // 9. 生成最终文本
	  let finalText = "";
	  
	  // 主导功能描述
	  for (let i = 0; i < dominantFunctions.length; i++) {
	    const [func, score] = dominantFunctions[i];
	    const descriptionIndex = score >= 20 ? 0 : 1;
	    const description = functionParagraphs[func][descriptionIndex];
	    
	    const order = i === 0 ? "主導" : 
	                 i === 1 ? "第二主導" : 
	                 i === 2 ? "第三主導" : "第四主導";
	                 
	    finalText += `<p><strong>${order}功能 ${func}</strong>：${description}</p>`;
	  }
	  
	  // 辅助功能描述
	  if (matchedAuxFunctions.length > 0) {
	    // 按分数排序辅助功能
	    matchedAuxFunctions.sort((a, b) => b[1] - a[1]);
	    
	    for (const [func, score] of matchedAuxFunctions) {
	      const strength = score >= topFuncScore * 0.75 ? 
	                      (Math.abs(score - topFuncScore) <= 3 ? "（較強）" : "") : 
	                      "（較弱）";
	      
	      const descriptionIndex = score >= 20 ? 0 : 1;
	      const description = functionParagraphs[func][descriptionIndex];
	      
	      // 找出相关的功能链
	      const relevantChains = functionChains.filter(chain => chain.includes(func));
	      
	      let chainText = "";
	      if (relevantChains.length > 0) {
	        chainText = `與${relevantChains.map(chain => {
	          const [domFunc] = chain.split('-');
	          return `主導功能${domFunc}組成${chain.split('(')[1].replace(')', '')}`;
	        }).join("，同時與")}`;
	      }
	      
	      finalText += `<p><strong>輔助功能${strength} ${func}</strong>${chainText ? ` ${chainText}` : ""}：${description}</p>`;
	    }
	  }
	  
	  return finalText;
	}

    const finalParagraph = generateFunctionAnalysis();

    const analysisDiv = document.getElementById('pairDescription');
    if (analysisDiv) {
      analysisDiv.innerHTML = `
        <h3>性格分析</h3>
        ${generateFunctionPoints()}
        ${finalParagraph}
      `;
    }
  </script>
</body>
</html>










